## Пример 5:

Этот код аналогичен предыдущему примеру (пример 4) и демонстрирует паттерн "Sharding" для балансировки нагрузки и распределения запросов. В этой версии уделено дополнительное внимание обеспечению потокобезопасности, чтобы гарантировать безопасный доступ к коду в условиях параллелизма. Вот как это работает:

1. **Структура данных**: Структура `Request` представляет отдельные запросы с `ID` (целое число) и `Data` (строка).

2. **Главная функция**:
   - Создается массив элементов `Request`, `requests`, для представления запросов, которые должны быть сбалансированы и распределены по шардам.
   - Создается срез срезов `Request`, `shards`, для имитации шардов. В данном случае создается три шарда.
   - Используется `sync.WaitGroup` (`wg`) для обеспечения завершения работы всех горутин перед продолжением.

3. **Горутины для распределения запросов**:
   - Для каждого `Request` в массиве `requests` запускается горутина. Каждая горутина ответственна за распределение запроса в один из трех шардов.
   - Функция `loadBalance` вычисляет индекс шарда для данного запроса на основе его `ID`, используя простую операцию взятия по модулю для равномерного распределения запросов между тремя шардами.

4. **Мьютексы для потокобезопасности**:
   - Для обеспечения потокобезопасности создается массив элементов `sync.Mutex`, `shardLocks`. Каждый элемент соответствует шарду и используется для синхронизации доступа к этому шарду.
   - Перед добавлением данных в шард горутина захватывает мьютекс для этого шарда с помощью `shardLocks[shardIndex].Lock()`.
   - После добавления данных в шард горутина освобождает мьютекс с помощью `shardLocks[shardIndex].Unlock()`.

5. **Ожидание завершения горутин**: Главная функция ждет завершения работы всех горутин с использованием оператора `wg.Wait()`.

6. **Вывод запросов из шардов**:
   - После распределения всех запросов главная функция переходит к выводу запросов из всех шардов.
   - Она перебирает срез `shards` и выводит идентификаторы запросов и данные внутри каждого шарда.

Этот код уделяет особое внимание потокобезопасности, используя мьютексы для защиты доступа к отдельным шардам. В результате он разработан для безопасного параллельного доступа, обеспечивая, что несколько горутин могут безопасно распределять запросы по разным шардам без конфликтов. Это в отличие от "Примера 4", где потокобезопасность не учитывалась и могли возникать гонки данных и проблемы при одновременном доступе.
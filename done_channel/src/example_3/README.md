## Пример 3:

Эта вариация вводит механизм ожидания для обработки ситуаций, когда горутина может не произвести результат своевременно, предотвращая потенциальные утечки ресурсов.

Вот как работает этот паттерн:

1. Создается канал `result` типа `interface{}`, который используется для приема результата каких-либо вычислений или операции, выполненной горутиной.

2. Создается канал `done` типа `struct{}` (пустая структура, также известная как сигнальный канал). Этот канал будет использоваться для сигнализации горутине остановиться, если возникает тайм-аут.

3. Запускается новая горутина, представляющая асинхронную задачу. Эта горутина пытается отправить результат в канал `result`. Однако она делает это внутри оператора `select`, который имеет два случая:
   - Первый случай пытается отправить результат в канал `result`, когда операция завершена.
   - Второй случай ожидает сигнала от канала `done`. Если канал `done` закрыт, он немедленно прерывает операцию, предотвращая блокировку на неопределенное время.

4. В основной части кода есть еще один оператор `select`. Он ожидает одного из двух событий:
   - Если результат получен из канала `result`, он обрабатывается.
   - Если проходит тайм-аут в одну секунду (как указано в `time.After(time.Second)`), выполняется обработка сценария тайм-аута.

5. После получения результата или возникновения тайм-аута код закрывает канал `done`, чтобы сигнализировать асинхронной горутине, что она должна провести очистку и завершиться.

Этот паттерн позволяет выполнять задачу параллельно с возможностью эффективной обработки тайм-аутов. Если асинхронная задача занимает слишком много времени для производства результата, механизм тайм-аута гарантирует, что ресурсы не будут связаны бесконечно. Это полезный паттерн, когда речь идет о сценариях, в которых своевременные ответы существенны, и вы хотите обеспечить грациозную обработку ситуаций, когда ответы задерживаются или не приходят.
## Пример 4:

Этот код демонстрирует сценарий, в котором "Паттерн канала завершения" не применяется непосредственно, но используется `context.Context` с механизмом отмены для достижения схожей цели.

Вот как работает этот код:

1. Функция `request` имитирует асинхронную операцию, которая занимает примерно 5 секунд на выполнение. Эта операция мониторится на предмет отмены через предоставленный `context.Context`.

2. В функции `main` создается `context` с помощью `context.WithCancel(context.Background())`, что позволяет отменить контекст по мере необходимости. Оператор `defer cancel()` используется для обеспечения отмены контекста, но он не используется для своевременной отмены. Вместо этого отмена выполняется явно позже в коде.

3. Создается буферизованный канал с именем `result` для приема результата операции `request`.

4. Запускается горутина для выполнения функции `request`. Горутина использует предоставленный контекст `ctx` для выполнения операции. Если операция завершается успешно, она отправляет результат в канал `result`. Если происходит ошибка или контекст отменяется, выводится сообщение об ошибке, но не происходит блокировка на неопределенное время.

5. Основная часть кода использует оператор `select` для ожидания одного из следующих условий:
   - Если результат получен из канала `result`, выводится результат.
   - Если прошла одна секунда (как указано в `time.After(time.Second)`), выводится сообщение "запрос превысил время ожидания".

6. После ожидания результата или истечения времени ожидания вызывается функция `cancel()` для явной отмены контекста. Это важно для обеспечения своевременной отмены и очистки.

7. Наконец, вводится небольшая задержка с помощью `time.Sleep`, чтобы предоставить времени подгорутине для вывода сообщения "отмена". Это не связано непосредственно с "Паттерном канала завершения", но служит в качестве механизма ожидания.

В этом коде `context.Context` используется для сигнализации и отмены операции, аналогично тому, как канал завершения использовался бы в "Паттерне канала завершения". Основное различие заключается в том, что отмена управляется самим `context`, что позволяет осуществить чистую и своевременную отмену операции, что является важным во многих сценариях параллелизма.
## Пример 3:
Этот код также демонстрирует паттерн "Fan-In" для объединения данных из нескольких каналов в один. Вот как это работает:

1. Функция `mergeData` принимает канал `done` и несколько каналов с данными (`datas...`) в качестве аргументов. Канал `done` используется для сигнализации завершения процесса объединения, а каналы `datas` содержат данные, которые нужно объединить.

2. Внутри функции `mergeData` создается `sync.WaitGroup` (`wg`) для отслеживания горутин, запущенных для каждого канала с данными. Создается еще один канал, `merged`, для хранения объединенных данных.

3. Для каждого канала с данными в срезе `datas` запускается горутина. Эти горутины непрерывно выбирают данные из входных каналов и отправляют их в канал `merged`. Они также слушают сигналы от канала `done` для остановки обработки и завершения.

4. Канал `merged` закрывается, когда все горутины завершили обработку своих данных. Отдельная горутина ожидает завершения горутин с использованием `wg.Wait()` и затем закрывает канал `merged` с помощью `close(merged)`.

5. В функции `main` создается канал `done` для сигнализации завершения процесса объединения. Этот канал откладывается для закрытия, чтобы обеспечить его закрытие при завершении программы.

6. Создаются два канала с данными (`data1` и `data2`) и заполняются целыми числами с использованием отдельных горутин.

7. Функция `mergeData` вызывается с каналом `done` и двумя каналами с данными в качестве аргументов. Эта функция объединяет данные из `data1` и `data2` в канале `merged`.

8. В функции `main` выполняется цикл для чтения и вывода значений из канала `merged` с использованием `for val := range merged`. Этот цикл продолжается до тех пор, пока все данные не будут объединены и обработаны.

В итоге этот код демонстрирует паттерн "Fan-In" для эффективного объединения данных из нескольких каналов в один. Использование канала `done` позволяет выполнять гармоничное завершение процесса объединения, и код эффективно объединяет данные из разных источников асинхронно.